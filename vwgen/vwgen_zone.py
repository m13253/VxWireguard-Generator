#!/usr/bin/env python3

# MIT License
#
# Copyright (c) 2018 Star Brilliant
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import encodings.idna
import errno
import ipaddress
import sys
import time
from typing import Any, Dict, List, Optional
from . import common


def main(argv: List[str]) -> int:
    if len(argv) < 4 or len(argv) % 2 != 0 or argv[2] == '--help':
        print_usage()
        return 0

    print(';; Generated by VxWireguard-Generator')

    return_value = 0

    for network_name, domain_suffix in zip(argv[2::2], argv[3::2]):
        config = common.Config()

        if not config.load(network_name):
            print("vwgen: Unable to find configuration file '{}.conf'".format(network_name), file=sys.stderr)
            return_value = return_value or errno.ENOENT
            continue

        network_name = config.network_name()
        domain_suffix = encodings.idna.ToASCII(''.join((c for c in domain_suffix.strip('.') + '.' if ord(c) > 32))).decode('ascii').lstrip('.')

        network: Dict[str, Any] = config.network()
        nodes: Dict[str, dict] = config.nodes()

        print()
        print(';; Network {}'.format(network_name))
        print('$ORIGIN                         {}'.format(domain_suffix))
        print('$TTL                            300')

        A_records: List[str] = []
        AAAA_records: List[str] = []
        PTR_IP_records: List[str] = []
        PTR_IP6_records: List[str] = []

        for node_name, node in nodes.items():
            safe_node_name = encodings.idna.ToASCII(''.join((c for c in node_name if ord(c) > 32))).decode('ascii')

            addresses: List[str] = node.get('Address', [])

            pubkey_ipv6: Optional[str] = common.generate_pubkey_ipv6(network, node)
            if pubkey_ipv6:
                addresses.append(pubkey_ipv6)

            for address in addresses:
                address = address.split('/', 1)[0]
                ip: Optional[ipaddress._BaseAddress] = None

                try:
                    ip = ipaddress.IPv4Address(address)
                except ipaddress.AddressValueError:
                    ip = None

                if ip is None:
                    try:
                        ip = ipaddress.IPv6Address(address)
                    except ipaddress.AddressValueError:
                        pass

                if ip is None:
                    print("vwgen: Invalid IP address '{}'".format(address), file=sys.stderr)
                    return_value = return_value or errno.EADDRNOTAVAIL
                    continue

                if isinstance(ip, ipaddress.IPv4Address):

                    A_records.append('{}300     IN      A       {}'.format(pad_to_tab(safe_node_name + '.' + domain_suffix, 32), ip.compressed))

                    PTR_IP_records.append('{}300     IN      PTR     {}.{}'.format(pad_to_tab(ip.reverse_pointer + '.', 32), safe_node_name, domain_suffix))

                elif isinstance(ip, ipaddress.IPv6Address):

                    AAAA_records.append('{}300     IN      AAAA    {}'.format(pad_to_tab(safe_node_name + '.' + domain_suffix, 32), ip.compressed))

                    PTR_IP6_records.append('{}300     IN      PTR     {}.{}'.format(pad_to_tab(ip.reverse_pointer + '.', 80), safe_node_name, domain_suffix))

        print('{}300     IN      SOA     ns1.{} hostmaster.{} {:.0f} 86400 7200 604800 300'.format(pad_to_tab(domain_suffix, 32), domain_suffix, domain_suffix, time.time()))

        for line in A_records:
            print(line)

        for line in AAAA_records:
            print(line)

        for line in PTR_IP_records:
            print(line)

        for line in PTR_IP6_records:
            print(line)

        config.close()

    return return_value


def print_usage() -> None:
    print('Usage: vwgen zone <network> <domain suffix> [<network> <domain suffix> ...]')


def pad_to_tab(s: str, min_width: int) -> str:
    return s.ljust(max(len(s), min_width - 1) // 8 * 8 + 8)


if __name__ == '__main__':
    sys.exit(main(sys.argv))
